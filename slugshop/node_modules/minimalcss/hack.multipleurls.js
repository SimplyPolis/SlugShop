const now = require('performance-now')
const puppeteer = require('puppeteer')
const csso = require('csso')
const csstree = require('css-tree')


if (process.argv.length <= 2) {
  console.log('Usage: ' + __filename + ' URL [URL2]')
  process.exit(-1)
}

const urls = process.argv.slice(2)
// if (urls.length > 1) {
//   throw new Error('Sorry, multiple URLs not supported yet')
// }

;(async urls => {

  const browser = await puppeteer.launch({})
  // const promises = []

  // console.log(urls);
  const promises = urls.map(async (url, i) => {
  // for(let i = 0; i < urls.length; i++){
    // const url = urls[i]
    // console.log(url, i);
    const page = await browser.newPage()
    // A must or else you can't do console.log from within page.evaluate()
    page.on('console', (...args) => {
      for (let i = 0; i < args.length; ++i) {
        console.log(`${i}: ${args[i]}`)
      }
    })
    await page.setRequestInterceptionEnabled(true)
    page.on('request', request => {
      if (/data:image\//.test(request.url)) {
        // don't need to download those
        request.abort()
      } else if (/\.(png|jpg|jpeg$)/.test(request.url)) {
        request.abort()
      } else {
        // XXX could do things like NOT download from domains like www.google-analytics.com
        request.continue()
      }
    })

    const stylesheetsContents = {}
    // To build up a map of all downloaded CSS
    page.on('response', response => {
      const url = response.url
      if (/\.css$/i.test(url)) {
        response.text().then(text => {
          const ast = csstree.parse(text, {
            parseValue: false,
            parseSelector: false
          })
          stylesheetsContents[url] = csstree.toPlainObject(ast)
        })
      }
    })

    await page.goto(url)
    // await page.screenshot({ path: `example${i}.png` })
    // promises.push(page)
    await page.evaluate('1 + 2')
    return stylesheetsContents
  })

  // console.log("PROMISES", promises);
  const evaluated = await Promise.all(promises)
  console.log('EVALUATED', evaluated);
  browser.close();
  // await page.goto(urls[0])
  // await page.screenshot({ path: 'example1.png' })
  // await page.goto(urls[1])
  // await page.screenshot({ path: 'example2.png' })
  // await page.goto('https://symbols.prod.mozaws.net')
  // await page.screenshot({ path: 'example.png' })
  // await page.goto('https://www.peterbe.com')
  // await page.screenshot({ path: 'example2.png' })

  // let url = urls[0]
  // urls.forEach(async url => {
  //   const t0 = now()
  //   await page.goto(url, { waitUntil: 'networkidle' })
  //   const t1 = now()
  //   // console.log('TOOK', (t1 - t0).toFixed() + 's')
  //
  //   await page.evaluate(() => {
  //     console.log("IN SIDE PAGE");
  //   })
  //   // const cleaned = await page.evaluate(stylesheetsContents => {
  //   //   // const cleaner = (ast, callback) => {
  //   //   //   const selectorToString = children => {
  //   //   //     let str = ''
  //   //   //     children.forEach(child => {
  //   //   //       if (child.type === 'IdSelector') {
  //   //   //         str += '#' + child.name
  //   //   //       } else if (child.type === 'ClassSelector') {
  //   //   //         str += '.' + child.name
  //   //   //       } else if (child.type === 'TypeSelector') {
  //   //   //         str += child.name
  //   //   //       } else if (child.type === 'WhiteSpace') {
  //   //   //         str += ' '
  //   //   //       } else if (child.type === 'Combinator') {
  //   //   //         str += ` ${child.name} `
  //   //   //       } else if (child.type === 'AttributeSelector') {
  //   //   //         if (child.value === null) {
  //   //   //           str += `[${child.name.name}]`
  //   //   //         } else if (child.value.value) {
  //   //   //           str += `[${child.name.name}${child.operator}${child.value.value}]`
  //   //   //         } else {
  //   //   //           str += `[${child.name.name}${child.operator}${child.value.name}]`
  //   //   //         }
  //   //   //       } else if (child.type === 'PseudoElementSelector') {
  //   //   //         str += `::${child.name}`
  //   //   //         if (child.children) {
  //   //   //           str += selectorToString(child.children)
  //   //   //         }
  //   //   //       } else if (child.type === 'PseudoClassSelector') {
  //   //   //         str += `:${child.name}`
  //   //   //         if (child.children) {
  //   //   //           str += selectorToString(child.children)
  //   //   //         }
  //   //   //       } else if (child.type === 'SelectorList') {
  //   //   //         str += selectorToString(child.children)
  //   //   //       } else if (child.type === 'Selector') {
  //   //   //         str += `(${selectorToString(child.children)})`
  //   //   //       } else if (child.type === 'Nth') {
  //   //   //         str += `(${child.nth.name})`
  //   //   //       } else if (child.type === 'Identifier') {
  //   //   //         str += `(${child.name})`
  //   //   //       } else {
  //   //   //         // console.error(child);
  //   //   //         // console.error(children);
  //   //   //         console.log('TYPE??', child.type, child)
  //   //   //         console.log(child)
  //   //   //         console.dir(children)
  //   //   //         throw new Error(child.type)
  //   //   //       }
  //   //   //     })
  //   //   //     if (str.indexOf('[object Object]') > -1) {
  //   //   //       console.log(str)
  //   //   //       console.log(children)
  //   //   //       throw new Error('selector string became [object Object]!')
  //   //   //     }
  //   //   //     if (str === '') {
  //   //   //       console.log(children)
  //   //   //       throw new Error('selector string became an empty string!')
  //   //   //     }
  //   //   //     return str
  //   //   //   }
  //   //   //
  //   //   //   const decisionsCache = {}
  //   //   //
  //   //   //   const clean = (children, callback) => {
  //   //   //     return children.filter(child => {
  //   //   //       if (child.type === 'Rule') {
  //   //   //         const values = child.selector.value.split(',').map(x => x.trim())
  //   //   //         // console.log(`VALUES ${values} ${values.length}`);
  //   //   //         const keepValues = values.filter(selectorString => {
  //   //   //           if (decisionsCache[selectorString] !== undefined) {
  //   //   //             return decisionsCache[selectorString]
  //   //   //           }
  //   //   //           const keep = callback(selectorString)
  //   //   //           decisionsCache[selectorString] = keep
  //   //   //           return keep
  //   //   //         })
  //   //   //         if (keepValues.length) {
  //   //   //           // re-write the selector value
  //   //   //           child.selector.value = keepValues.join(', ')
  //   //   //           return true
  //   //   //         } else {
  //   //   //           // children.remove(child)
  //   //   //           return false
  //   //   //         }
  //   //   //         // console.log(`KEEPVALUES ${keepValues} ${keepValues.length}`);
  //   //   //         // console.log(values);
  //   //   //         // child.selector.children = child.selector.children.filter(
  //   //   //         //   selectorChild => {
  //   //   //         //     // const selectorString = selectorChild.value
  //   //   //         //     // console.log(`selectorString '${selectorString}'`);
  //   //   //         //     const selectorString = selectorToString(selectorChild.children)
  //   //   //         //     if (decisionsCache[selectorString] !== undefined) {
  //   //   //         //       return decisionsCache[selectorString]
  //   //   //         //     }
  //   //   //         //     const keep = callback(selectorString)
  //   //   //         //     decisionsCache[selectorString] = keep
  //   //   //         //     return keep
  //   //   //         //   }
  //   //   //         // )
  //   //   //         // return child.selector.children.length > 0
  //   //   //       } else if (
  //   //   //         child.type === 'Atrule' &&
  //   //   //         child.expression &&
  //   //   //         child.expression.type === 'MediaQueryList'
  //   //   //       ) {
  //   //   //         // recurse
  //   //   //         child.block.children = clean(child.block.children, callback)
  //   //   //         return child.block.children.length > 0
  //   //   //       } else {
  //   //   //         // console.log(child.type);
  //   //   //         // console.dir(child)
  //   //   //       }
  //   //   //       return true
  //   //   //     })
  //   //   //   }
  //   //   //
  //   //   //   ast.children = clean(ast.children, callback)
  //   //   //   return ast
  //   //   // }
  //   //   //
  //   //   // const objsCleaned = {}
  //   //   //
  //   //   // const links = Array.from(document.querySelectorAll('link'))
  //   //   // links
  //   //   //   .filter(link => {
  //   //   //     return (
  //   //   //       link.href &&
  //   //   //       (link.rel === 'stylesheet' ||
  //   //   //         link.href.toLowerCase().endsWith('.css')) && link.media !== 'print'
  //   //   //     )
  //   //   //   })
  //   //   //   .forEach(stylesheet => {
  //   //   //     // XXX Need to make sure 'stylesheet.href' is an absolute full URL
  //   //   //     const obj = stylesheetsContents[stylesheet.href]
  //   //   //     objsCleaned[stylesheet.href] = cleaner(obj, selector => {
  //   //   //       // console.log(`selector '${selector}'`);
  //   //   //       // Here's the crucial part. Decide whether to keep the selector
  //   //   //       // Avoid doing a querySelector on hacks that will fail
  //   //   //       if (/:-(ms|moz)-/.test(selector)) {
  //   //   //         // '.form-control:-ms-input-placeholder'
  //   //   //         return true
  //   //   //       }
  //   //   //       try {
  //   //   //         const keep = !!document.querySelector(selector)
  //   //   //         // if (keep) {
  //   //   //         //   console.log(`KEEP '${selector}'`);
  //   //   //         // } else {
  //   //   //         //   console.log(`DISCARD '${selector}'`);
  //   //   //         // }
  //   //   //         return keep
  //   //   //       } catch (ex) {
  //   //   //         console.error('EXCEPTION!!!!', selector, ex.toString())
  //   //   //         return true
  //   //   //       }
  //   //   //     })
  //   //   //   })
  //   //   // return Promise.resolve(objsCleaned)
  //   // }, stylesheetsContents)
  //
  // })

  // const combinedCSS = Object.keys(cleaned).map(url => {
  //   // console.log('For URL', url);
  //   const obj = cleaned[url]
  //   // console.log(typeof cleanedAst)
  //   const cleanedAst = csstree.fromPlainObject(obj)
  //   // csstree.walk(cleanedAst, n => console.log(n))
  //   // csstree.walk(cleanedAst, (node) => {
  //   //   if (node.type === 'Rule' && node.selector.type === 'Raw') {
  //   //     node.selector = csstree.parse(node.selector.value, { context: 'selectorList' });
  //   //   }
  //   // })
  //   // console.log('AFTER.......');
  //   // csstree.walk(cleanedAst, n => console.log(n))
  //   // csstree.walk(cleanedAst, n => console.log(n))
  //   // console.log(cleanedAst.children);
  //   // console.dir(cleanedAst.children);
  //   // var compressedAst = csso.compress(cleanedAst).ast;
  //   // var minifiedCss = csso.syntax.translate(compressedAst);
  //   // console.log(minifiedCss);
  //   // csstree.walk(cleanedAst, n => {
  //   //   console.log('NODE', n);
  //   // })
  //   const cleanedCSS = csstree.translate(cleanedAst)
  //   // console.log(cleanedCSS);
  //   // console.log('-----------------------');
  //   // var minifiedCss = csso.minify(minifiedCss).css;
  //   // console.log(cleanedCSS);
  //   // console.log(minifiedCss);
  //   // console.log('\n\n');
  //   return cleanedCSS
  // }).join('\n')
  //
  // console.log('===========================================================');
  // console.log(`Combined CSS for ${url}`);
  // console.log(combinedCSS);
  // console.log('--------------------');
  // var minifiedCss = csso.minify(combinedCSS).css;
  // console.log(minifiedCss);
  browser.close()

  // return Promise.resolve(minifiedCss)
  // return minifiedCss
})(urls)
