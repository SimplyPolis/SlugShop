const now = require('performance-now')
const puppeteer = require('puppeteer')
const csso = require('csso')
const csstree = require('css-tree')


if (process.argv.length <= 2) {
  console.log('Usage: ' + __filename + ' URL [URL2]')
  process.exit(-1)
}

const urls = process.argv.slice(2)
if (urls.length > 1) {
  throw new Error('Sorry, multiple URLs not supported yet')
}

;(async urls => {

  const browser = await puppeteer.launch()
  const page = await browser.newPage()

  // A must or else you can't do console.log from within page.evaluate()
  page.on('console', (...args) => {
    // XXX Should we install just call console.log(...args)?
    for (let i = 0; i < args.length; ++i) {
      console.log(`${i}: ${args[i]}`)
    }
  })

  await page.setRequestInterceptionEnabled(true)
  page.on('request', request => {
    if (/data:image\//.test(request.url)) {
      // don't need to download those
      request.abort()
    } else if (/\.(png|jpg|jpeg$)/.test(request.url)) {
      request.abort()
    } else {
      // XXX could do things like NOT download from domains like www.google-analytics.com
      request.continue()
    }
  })

  const stylesheetsContents = {}
  // To build up a map of all downloaded CSS
  page.on('response', response => {
    const url = response.url
    if (/\.css$/i.test(url)) {
      response.text().then(text => {
        const ast = csstree.parse(text, {
          parseValue: false,
          parseSelector: false
        })
        stylesheetsContents[url] = csstree.toPlainObject(ast)
      })
    }
  })

  let url = urls[0]
  await page.goto(url, { waitUntil: 'networkidle' })

  const cleaned = await page.evaluate(stylesheetsContents => {
    const cleaner = (ast, callback) => {
      const selectorToString = children => {
        let str = ''
        children.forEach(child => {
          if (child.type === 'IdSelector') {
            str += '#' + child.name
          } else if (child.type === 'ClassSelector') {
            str += '.' + child.name
          } else if (child.type === 'TypeSelector') {
            str += child.name
          } else if (child.type === 'WhiteSpace') {
            str += ' '
          } else if (child.type === 'Combinator') {
            str += ` ${child.name} `
          } else if (child.type === 'AttributeSelector') {
            if (child.value === null) {
              str += `[${child.name.name}]`
            } else if (child.value.value) {
              str += `[${child.name.name}${child.operator}${child.value.value}]`
            } else {
              str += `[${child.name.name}${child.operator}${child.value.name}]`
            }
          } else if (child.type === 'PseudoElementSelector') {
            str += `::${child.name}`
            if (child.children) {
              str += selectorToString(child.children)
            }
          } else if (child.type === 'PseudoClassSelector') {
            str += `:${child.name}`
            if (child.children) {
              str += selectorToString(child.children)
            }
          } else if (child.type === 'SelectorList') {
            str += selectorToString(child.children)
          } else if (child.type === 'Selector') {
            str += `(${selectorToString(child.children)})`
          } else if (child.type === 'Nth') {
            str += `(${child.nth.name})`
          } else if (child.type === 'Identifier') {
            str += `(${child.name})`
          } else {
            // console.error(child);
            // console.error(children);
            console.log('TYPE??', child.type, child)
            console.log(child)
            console.dir(children)
            throw new Error(child.type)
          }
        })
        if (str.indexOf('[object Object]') > -1) {
          console.log(str)
          console.log(children)
          throw new Error('selector string became [object Object]!')
        }
        if (str === '') {
          console.log(children)
          throw new Error('selector string became an empty string!')
        }
        return str
      }

      const decisionsCache = {}

      const clean = (children, callback) => {
        return children.filter(child => {
          if (child.type === 'Rule') {
            const values = child.selector.value.split(',').map(x => x.trim())
            // console.log(`VALUES ${values} ${values.length}`);
            const keepValues = values.filter(selectorString => {
              if (decisionsCache[selectorString] !== undefined) {
                return decisionsCache[selectorString]
              }
              const keep = callback(selectorString)
              decisionsCache[selectorString] = keep
              return keep
            })
            if (keepValues.length) {
              // re-write the selector value
              child.selector.value = keepValues.join(', ')
              return true
            } else {
              // children.remove(child)
              return false
            }
            // console.log(`KEEPVALUES ${keepValues} ${keepValues.length}`);
            // console.log(values);
            // child.selector.children = child.selector.children.filter(
            //   selectorChild => {
            //     // const selectorString = selectorChild.value
            //     // console.log(`selectorString '${selectorString}'`);
            //     const selectorString = selectorToString(selectorChild.children)
            //     if (decisionsCache[selectorString] !== undefined) {
            //       return decisionsCache[selectorString]
            //     }
            //     const keep = callback(selectorString)
            //     decisionsCache[selectorString] = keep
            //     return keep
            //   }
            // )
            // return child.selector.children.length > 0
          } else if (
            child.type === 'Atrule' &&
            child.expression &&
            child.expression.type === 'MediaQueryList'
          ) {
            // recurse
            child.block.children = clean(child.block.children, callback)
            return child.block.children.length > 0
          } else {
            // console.log(child.type);
            // console.dir(child)
          }
          return true
        })
      }

      ast.children = clean(ast.children, callback)
      return ast
    }

    const objsCleaned = {}

    const links = Array.from(document.querySelectorAll('link'))
    links
      .filter(link => {
        return (
          link.href &&
          (link.rel === 'stylesheet' ||
            link.href.toLowerCase().endsWith('.css')) && link.media !== 'print'
        )
      })
      .forEach(stylesheet => {
        // XXX Need to make sure 'stylesheet.href' is an absolute full URL
        const obj = stylesheetsContents[stylesheet.href]
        objsCleaned[stylesheet.href] = cleaner(obj, selector => {
          // console.log(`selector '${selector}'`);
          // Here's the crucial part. Decide whether to keep the selector
          // Avoid doing a querySelector on hacks that will fail
          if (/:-(ms|moz)-/.test(selector)) {
            // '.form-control:-ms-input-placeholder'
            return true
          }
          try {
            const keep = !!document.querySelector(selector)
            // if (keep) {
            //   console.log(`KEEP '${selector}'`);
            // } else {
            //   console.log(`DISCARD '${selector}'`);
            // }
            return keep
          } catch (ex) {
            console.error('EXCEPTION!!!!', selector, ex.toString())
            return true
          }
        })
      })
    return Promise.resolve(objsCleaned)
  }, stylesheetsContents)

  const combinedCSS = Object.keys(cleaned).map(url => {
    // console.log('For URL', url);
    const obj = cleaned[url]
    // console.log(typeof cleanedAst)
    const cleanedAst = csstree.fromPlainObject(obj)
    console.log('cleanedAst', cleanedAst)
    // csstree.walk(cleanedAst, n => console.log(n))
    // csstree.walk(cleanedAst, (node) => {
    //   if (node.type === 'Rule' && node.selector.type === 'Raw') {
    //     node.selector = csstree.parse(node.selector.value, { context: 'selectorList' });
    //   }
    // })
    // console.log('AFTER.......');
    // csstree.walk(cleanedAst, n => console.log(n))
    // csstree.walk(cleanedAst, n => console.log(n))
    // console.log(cleanedAst.children);
    // console.dir(cleanedAst.children);
    // var compressedAst = csso.compress(cleanedAst).ast;
    // var minifiedCss = csso.syntax.translate(compressedAst);
    // console.log(minifiedCss);
    // csstree.walk(cleanedAst, n => {
    //   console.log('NODE', n);
    // })
    const cleanedCSS = csstree.translate(cleanedAst)
    // console.log(cleanedCSS);
    // console.log('-----------------------');
    // var minifiedCss = csso.minify(minifiedCss).css;
    // console.log(cleanedCSS);
    // console.log(minifiedCss);
    // console.log('\n\n');
    return cleanedCSS
  }).join('\n')

  console.log('===========================================================');
  console.log(`Combined CSS for ${url}`);
  console.log(combinedCSS);
  console.log('--------------------');
  var minifiedCss = csso.minify(combinedCSS).css;
  console.log(minifiedCss);
  browser.close()

})(urls)
