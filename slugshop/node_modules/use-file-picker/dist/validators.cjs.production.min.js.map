{"version":3,"file":"validators.cjs.production.min.js","sources":["../src/validators/validatorBase.ts","../src/validators/fileAmountLimitValidator/index.ts","../src/validators/fileSizeValidator/index.ts","../src/validators/imageDimensionsValidator/index.ts","../src/validators/persistentFileAmountLimitValidator/index.ts","../src/validators/FileTypeValidator/index.ts"],"sourcesContent":["import { FileWithPath } from 'file-selector';\nimport {\n  ExtractContentTypeFromConfig,\n  FileErrors,\n  SelectedFiles,\n  SelectedFilesOrErrors,\n  UseFilePickerConfig,\n} from '../interfaces';\n\nexport abstract class Validator<\n  CustomErrors = unknown,\n  ConfigType extends UseFilePickerConfig<CustomErrors> = UseFilePickerConfig<any>\n> {\n  protected invokerHookId: string | undefined;\n\n  /**\n   * This method is called before parsing the selected files. It is called once per selection.\n   * @param config passed to the useFilePicker hook\n   * @param plainFiles files selected by the user\n   */\n  abstract validateBeforeParsing(config: ConfigType, plainFiles: File[]): Promise<void>;\n  /**\n   * This method is called after parsing the selected files. It is called once per every parsed file.\n   * @param config passed to the useFilePicker hook\n   * @param file parsed file selected by the user\n   * @param reader instance that was used to parse the file\n   */\n  abstract validateAfterParsing(config: ConfigType, file: FileWithPath, reader: FileReader): Promise<void>;\n\n  /**\n   * lifecycle method called after user selection (regardless of validation result)\n   */\n  onFilesSelected(\n    _data: SelectedFilesOrErrors<ExtractContentTypeFromConfig<ConfigType>, CustomErrors>\n  ): Promise<void> | void {}\n  /**\n   * lifecycle method called after successful validation\n   */\n  onFilesSuccessfullySelected(_data: SelectedFiles<ExtractContentTypeFromConfig<ConfigType>>): Promise<void> | void {}\n  /**\n   * lifecycle method called after failed validation\n   */\n  onFilesRejected(_data: FileErrors<CustomErrors>): Promise<void> | void {}\n  /**\n   * lifecycle method called after the selection is cleared\n   */\n  onClear(): Promise<void> | void {}\n\n  /**\n   * This method is called when file is removed from the list of selected files.\n   * Invoked only by the useImperativeFilePicker hook\n   * @param _removedFile removed file\n   * @param _removedIndex index of removed file\n   */\n  onFileRemoved(_removedFile: File, _removedIndex: number): Promise<void> | void {}\n}\n","import { FileAmountLimitError, FileAmountLimitConfig, UseFilePickerConfig } from '../../interfaces';\nimport { Validator } from '../validatorBase';\n\nexport default class FileAmountLimitValidator extends Validator {\n  constructor(private limitAmountOfFilesConfig: FileAmountLimitConfig) {\n    super();\n  }\n\n  validateBeforeParsing(_config: UseFilePickerConfig, plainFiles: File[]): Promise<void> {\n    const { min, max } = this.limitAmountOfFilesConfig;\n    if (max && plainFiles.length > max) {\n      return Promise.reject({\n        name: 'FileAmountLimitError',\n        reason: 'MAX_AMOUNT_OF_FILES_EXCEEDED',\n      } as FileAmountLimitError);\n    }\n\n    if (min && plainFiles.length < min) {\n      return Promise.reject({\n        name: 'FileAmountLimitError',\n        reason: 'MIN_AMOUNT_OF_FILES_NOT_REACHED',\n      } as FileAmountLimitError);\n    }\n    return Promise.resolve();\n  }\n  validateAfterParsing(): Promise<void> {\n    return Promise.resolve();\n  }\n}\n","import { FileWithPath } from 'file-selector';\nimport { FileSizeError, FileSizeRestrictions, UseFilePickerConfig } from '../../interfaces';\nimport { Validator } from '../validatorBase';\n\nexport default class FileSizeValidator extends Validator {\n  constructor(private fileSizeRestrictions: FileSizeRestrictions) {\n    super();\n  }\n\n  async validateBeforeParsing(_config: UseFilePickerConfig, plainFiles: File[]): Promise<void> {\n    const { minFileSize, maxFileSize } = this.fileSizeRestrictions;\n\n    if (!minFileSize && !maxFileSize) {\n      return Promise.resolve();\n    }\n\n    const errors = plainFiles\n      .map(file => getFileSizeError({ minFileSize, maxFileSize, file }))\n      .filter(error => !!error) as FileSizeError[];\n\n    return errors.length > 0 ? Promise.reject(errors) : Promise.resolve();\n  }\n  async validateAfterParsing(_config: UseFilePickerConfig, _file: FileWithPath): Promise<void> {\n    return Promise.resolve();\n  }\n}\n\nconst getFileSizeError = ({\n  file,\n  maxFileSize,\n  minFileSize,\n}: {\n  minFileSize: number | undefined;\n  maxFileSize: number | undefined;\n  file: FileWithPath;\n}): FileSizeError | undefined => {\n  if (minFileSize) {\n    const minBytes = minFileSize;\n    if (file.size < minBytes) {\n      return { name: 'FileSizeError', reason: 'FILE_SIZE_TOO_SMALL', causedByFile: file };\n    }\n  }\n  if (maxFileSize) {\n    const maxBytes = maxFileSize;\n    if (file.size > maxBytes) {\n      return { name: 'FileSizeError', reason: 'FILE_SIZE_TOO_LARGE', causedByFile: file };\n    }\n  }\n};\n","import { FileWithPath } from 'file-selector';\nimport { ImageDimensionError, ImageDimensionRestrictionsConfig, UseFilePickerConfig } from '../../interfaces';\nimport { Validator } from '../validatorBase';\n\nexport default class ImageDimensionsValidator extends Validator {\n  constructor(private imageSizeRestrictions: ImageDimensionRestrictionsConfig) {\n    super();\n  }\n\n  validateBeforeParsing(): Promise<void> {\n    return Promise.resolve();\n  }\n  validateAfterParsing(config: UseFilePickerConfig, file: FileWithPath, reader: FileReader): Promise<void> {\n    const { readAs } = config;\n    if (readAs === 'DataURL' && this.imageSizeRestrictions && isImage(file.type)) {\n      return checkImageDimensions(file, reader.result as string, this.imageSizeRestrictions);\n    }\n    return Promise.resolve();\n  }\n}\n\nconst isImage = (fileType: string) => fileType.startsWith('image');\n\nconst checkImageDimensions = (\n  file: FileWithPath,\n  imgDataURL: string,\n  imageSizeRestrictions: ImageDimensionRestrictionsConfig\n) =>\n  new Promise<void>((resolve, reject) => {\n    const img = new Image();\n    let error: ImageDimensionError = {\n      name: 'ImageDimensionError',\n      causedByFile: file,\n      reasons: [],\n    };\n    img.onload = function () {\n      const { maxHeight, maxWidth, minHeight, minWidth } = imageSizeRestrictions;\n      const { width, height } = this as unknown as typeof img;\n\n      if (maxHeight && maxHeight < height) error.reasons.push('IMAGE_HEIGHT_TOO_BIG');\n      if (minHeight && minHeight > height) error.reasons.push('IMAGE_HEIGHT_TOO_SMALL');\n      if (maxWidth && maxWidth < width) error.reasons.push('IMAGE_WIDTH_TOO_BIG');\n      if (minWidth && minWidth > width) error.reasons.push('IMAGE_WIDTH_TOO_SMALL');\n      error.reasons.length ? reject(error) : resolve();\n    };\n    img.onerror = function () {\n      error.reasons.push('IMAGE_NOT_LOADED');\n      reject(error);\n    };\n    img.src = imgDataURL;\n  });\n","import { FileAmountLimitConfig, FileAmountLimitError, UseFilePickerConfig } from '../../interfaces';\nimport { Validator } from '../validatorBase';\n\nclass PersistentFileAmountLimitValidator extends Validator {\n  private previousPlainFiles: File[] = [];\n\n  constructor(private limitFilesConfig: FileAmountLimitConfig) {\n    super();\n  }\n\n  onClear(): void {\n    this.previousPlainFiles = [];\n  }\n\n  onFileRemoved(_removedFile: File, removedIndex: number): void {\n    this.previousPlainFiles.splice(removedIndex, 1);\n  }\n\n  validateBeforeParsing(_config: UseFilePickerConfig, plainFiles: File[]): Promise<void> {\n    const fileAmount = this.previousPlainFiles.length + plainFiles.length;\n    const { min, max } = this.limitFilesConfig;\n    if (max && fileAmount > max) {\n      return Promise.reject({\n        name: 'FileAmountLimitError',\n        reason: 'MAX_AMOUNT_OF_FILES_EXCEEDED',\n      } as FileAmountLimitError);\n    }\n\n    if (min && fileAmount < min) {\n      return Promise.reject({\n        name: 'FileAmountLimitError',\n        reason: 'MIN_AMOUNT_OF_FILES_NOT_REACHED',\n      } as FileAmountLimitError);\n    }\n\n    this.previousPlainFiles = [...this.previousPlainFiles, ...plainFiles];\n\n    return Promise.resolve();\n  }\n\n  validateAfterParsing(): Promise<void> {\n    return Promise.resolve();\n  }\n}\n\nexport default PersistentFileAmountLimitValidator;\n","import { FileWithPath, UseFilePickerConfig } from '../../interfaces';\nimport { Validator } from '../validatorBase';\n\nexport default class FileTypeValidator extends Validator {\n  constructor(private readonly acceptedFileExtensions: string[]) {\n    super();\n  }\n\n  validateBeforeParsing(_config: UseFilePickerConfig<any>, plainFiles: File[]): Promise<void> {\n    const fileExtensionErrors = plainFiles.reduce<{ name: string; reason: string; causedByFile: File }[]>(\n      (errors, currentFile) => {\n        const fileExtension = currentFile.name.split('.').pop();\n        if (!fileExtension) {\n          return [\n            ...errors,\n            {\n              name: 'FileTypeError',\n              reason: 'FILE_EXTENSION_NOT_FOUND',\n              causedByFile: currentFile,\n            },\n          ];\n        }\n        if (!this.acceptedFileExtensions.includes(fileExtension)) {\n          return [\n            ...errors,\n            {\n              name: 'FileTypeError',\n              reason: 'FILE_TYPE_NOT_ACCEPTED',\n              causedByFile: currentFile,\n            },\n          ];\n        }\n\n        return errors;\n      },\n      []\n    );\n\n    return fileExtensionErrors.length > 0 ? Promise.reject(fileExtensionErrors) : Promise.resolve();\n  }\n\n  validateAfterParsing(_config: UseFilePickerConfig<any>, _file: FileWithPath, _reader: FileReader): Promise<void> {\n    return Promise.resolve();\n  }\n}\n"],"names":["Validator","this","invokerHookId","_proto","prototype","onFilesSelected","_data","onFilesSuccessfullySelected","onFilesRejected","onClear","onFileRemoved","_removedFile","_removedIndex","FileAmountLimitValidator","_Validator","limitAmountOfFilesConfig","_this","call","_inheritsLoose","validateBeforeParsing","_config","plainFiles","_this$limitAmountOfFi","min","max","length","Promise","reject","name","reason","resolve","validateAfterParsing","FileSizeValidator","fileSizeRestrictions","_validateBeforeParsing","_asyncToGenerator","_regeneratorRuntime","mark","_callee","_this$fileSizeRestric","minFileSize","maxFileSize","errors","wrap","_context","prev","next","abrupt","map","file","getFileSizeError","filter","error","stop","_x","_x2","apply","arguments","_validateAfterParsing","_callee2","_file","_context2","_x3","_x4","_ref","size","causedByFile","ImageDimensionsValidator","imageSizeRestrictions","config","reader","readAs","isImage","type","checkImageDimensions","result","fileType","startsWith","imgDataURL","img","Image","reasons","onload","maxHeight","maxWidth","minHeight","minWidth","width","height","push","onerror","src","PersistentFileAmountLimitValidator","limitFilesConfig","previousPlainFiles","removedIndex","splice","fileAmount","_this$limitFilesConfi","concat","FileTypeValidator","acceptedFileExtensions","_this2","fileExtensionErrors","reduce","currentFile","fileExtension","split","pop","includes","_reader"],"mappings":"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"}